/*
 * generated by Xtext 2.15.0
 */
package org.xtext.imt.browserautomation.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.imt.browserautomation.browserAutomation.AFFECTATION;
import org.xtext.imt.browserautomation.browserAutomation.BUTTON;
import org.xtext.imt.browserautomation.browserAutomation.BrowserAutomationPackage;
import org.xtext.imt.browserautomation.browserAutomation.CHECKBOX;
import org.xtext.imt.browserautomation.browserAutomation.CHECK_BOXE;
import org.xtext.imt.browserautomation.browserAutomation.CHOOSE_COMBOBOX;
import org.xtext.imt.browserautomation.browserAutomation.CLICK_ON;
import org.xtext.imt.browserautomation.browserAutomation.COMBOBOX;
import org.xtext.imt.browserautomation.browserAutomation.Element;
import org.xtext.imt.browserautomation.browserAutomation.GO_TO_URL;
import org.xtext.imt.browserautomation.browserAutomation.IMAGE;
import org.xtext.imt.browserautomation.browserAutomation.INSERT_ON;
import org.xtext.imt.browserautomation.browserAutomation.LINK;
import org.xtext.imt.browserautomation.browserAutomation.OPEN_BROWSER;
import org.xtext.imt.browserautomation.browserAutomation.PARAMS;
import org.xtext.imt.browserautomation.browserAutomation.READ_ON;
import org.xtext.imt.browserautomation.browserAutomation.RefElement;
import org.xtext.imt.browserautomation.browserAutomation.SEARCH_FIELD;
import org.xtext.imt.browserautomation.browserAutomation.SELECTOR;
import org.xtext.imt.browserautomation.browserAutomation.TEXT;
import org.xtext.imt.browserautomation.browserAutomation.Test;
import org.xtext.imt.browserautomation.browserAutomation.VERIFY_THAT;
import org.xtext.imt.browserautomation.services.BrowserAutomationGrammarAccess;

@SuppressWarnings("all")
public class BrowserAutomationSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private BrowserAutomationGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == BrowserAutomationPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BrowserAutomationPackage.AFFECTATION:
				sequence_AFFECTATION(context, (AFFECTATION) semanticObject); 
				return; 
			case BrowserAutomationPackage.BUTTON:
				sequence_BUTTON(context, (BUTTON) semanticObject); 
				return; 
			case BrowserAutomationPackage.CHECKBOX:
				sequence_CHECKBOX(context, (CHECKBOX) semanticObject); 
				return; 
			case BrowserAutomationPackage.CHECK_BOXE:
				sequence_CHECK_BOXE(context, (CHECK_BOXE) semanticObject); 
				return; 
			case BrowserAutomationPackage.CHOOSE_COMBOBOX:
				sequence_CHOOSE_COMBOBOX(context, (CHOOSE_COMBOBOX) semanticObject); 
				return; 
			case BrowserAutomationPackage.CLICK_ON:
				sequence_CLICK_ON(context, (CLICK_ON) semanticObject); 
				return; 
			case BrowserAutomationPackage.COMBOBOX:
				sequence_COMBOBOX(context, (COMBOBOX) semanticObject); 
				return; 
			case BrowserAutomationPackage.ELEMENT:
				sequence_Element(context, (Element) semanticObject); 
				return; 
			case BrowserAutomationPackage.GO_TO_URL:
				sequence_GO_TO_URL(context, (GO_TO_URL) semanticObject); 
				return; 
			case BrowserAutomationPackage.IMAGE:
				sequence_IMAGE(context, (IMAGE) semanticObject); 
				return; 
			case BrowserAutomationPackage.INSERT_ON:
				sequence_INSERT_ON(context, (INSERT_ON) semanticObject); 
				return; 
			case BrowserAutomationPackage.LINK:
				sequence_LINK(context, (LINK) semanticObject); 
				return; 
			case BrowserAutomationPackage.OPEN_BROWSER:
				sequence_OPEN_BROWSER(context, (OPEN_BROWSER) semanticObject); 
				return; 
			case BrowserAutomationPackage.PARAMS:
				sequence_PARAMS(context, (PARAMS) semanticObject); 
				return; 
			case BrowserAutomationPackage.READ_ON:
				sequence_READ_ON(context, (READ_ON) semanticObject); 
				return; 
			case BrowserAutomationPackage.REF_ELEMENT:
				sequence_RefElement(context, (RefElement) semanticObject); 
				return; 
			case BrowserAutomationPackage.SEARCH_FIELD:
				sequence_SEARCH_FIELD(context, (SEARCH_FIELD) semanticObject); 
				return; 
			case BrowserAutomationPackage.SELECTOR:
				sequence_SELECTOR(context, (SELECTOR) semanticObject); 
				return; 
			case BrowserAutomationPackage.TEXT:
				sequence_TEXT(context, (TEXT) semanticObject); 
				return; 
			case BrowserAutomationPackage.TEST:
				sequence_Test(context, (Test) semanticObject); 
				return; 
			case BrowserAutomationPackage.VERIFY_THAT:
				sequence_VERIFY_THAT(context, (VERIFY_THAT) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Instruction returns AFFECTATION
	 *     AFFECTATION returns AFFECTATION
	 *
	 * Constraint:
	 *     (name=ID selector=SELECTOR)
	 */
	protected void sequence_AFFECTATION(ISerializationContext context, AFFECTATION semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BrowserAutomationPackage.Literals.AFFECTATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BrowserAutomationPackage.Literals.AFFECTATION__NAME));
			if (transientValues.isValueTransient(semanticObject, BrowserAutomationPackage.Literals.AFFECTATION__SELECTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BrowserAutomationPackage.Literals.AFFECTATION__SELECTOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAFFECTATIONAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAFFECTATIONAccess().getSelectorSELECTORParserRuleCall_3_0(), semanticObject.getSelector());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Readable returns BUTTON
	 *     Verifiable returns BUTTON
	 *     Clickable returns BUTTON
	 *     BUTTON returns BUTTON
	 *
	 * Constraint:
	 *     name=STRING
	 */
	protected void sequence_BUTTON(ISerializationContext context, BUTTON semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BrowserAutomationPackage.Literals.BUTTON__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BrowserAutomationPackage.Literals.BUTTON__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBUTTONAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CHECKBOX returns CHECKBOX
	 *
	 * Constraint:
	 *     name=STRING
	 */
	protected void sequence_CHECKBOX(ISerializationContext context, CHECKBOX semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BrowserAutomationPackage.Literals.CHECKBOX__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BrowserAutomationPackage.Literals.CHECKBOX__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCHECKBOXAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns CHECK_BOXE
	 *     CHECK_BOXE returns CHECK_BOXE
	 *
	 * Constraint:
	 *     element+=CHECKBOX+
	 */
	protected void sequence_CHECK_BOXE(ISerializationContext context, CHECK_BOXE semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns CHOOSE_COMBOBOX
	 *     CHOOSE_COMBOBOX returns CHOOSE_COMBOBOX
	 *
	 * Constraint:
	 *     (element=COMBOBOX data=STRING)
	 */
	protected void sequence_CHOOSE_COMBOBOX(ISerializationContext context, CHOOSE_COMBOBOX semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BrowserAutomationPackage.Literals.CHOOSE_COMBOBOX__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BrowserAutomationPackage.Literals.CHOOSE_COMBOBOX__ELEMENT));
			if (transientValues.isValueTransient(semanticObject, BrowserAutomationPackage.Literals.CHOOSE_COMBOBOX__DATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BrowserAutomationPackage.Literals.CHOOSE_COMBOBOX__DATA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCHOOSE_COMBOBOXAccess().getElementCOMBOBOXParserRuleCall_1_0(), semanticObject.getElement());
		feeder.accept(grammarAccess.getCHOOSE_COMBOBOXAccess().getDataSTRINGTerminalRuleCall_3_0(), semanticObject.getData());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns CLICK_ON
	 *     CLICK_ON returns CLICK_ON
	 *
	 * Constraint:
	 *     element=Clickable
	 */
	protected void sequence_CLICK_ON(ISerializationContext context, CLICK_ON semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BrowserAutomationPackage.Literals.CLICK_ON__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BrowserAutomationPackage.Literals.CLICK_ON__ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCLICK_ONAccess().getElementClickableParserRuleCall_1_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Clickable returns COMBOBOX
	 *     COMBOBOX returns COMBOBOX
	 *
	 * Constraint:
	 *     name=STRING
	 */
	protected void sequence_COMBOBOX(ISerializationContext context, COMBOBOX semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BrowserAutomationPackage.Literals.COMBOBOX__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BrowserAutomationPackage.Literals.COMBOBOX__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCOMBOBOXAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Element
	 *
	 * Constraint:
	 *     Id=ID
	 */
	protected void sequence_Element(ISerializationContext context, Element semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BrowserAutomationPackage.Literals.ELEMENT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BrowserAutomationPackage.Literals.ELEMENT__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementAccess().getIdIDTerminalRuleCall_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns GO_TO_URL
	 *     GO_TO_URL returns GO_TO_URL
	 *
	 * Constraint:
	 *     url=STRING
	 */
	protected void sequence_GO_TO_URL(ISerializationContext context, GO_TO_URL semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BrowserAutomationPackage.Literals.GO_TO_URL__URL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BrowserAutomationPackage.Literals.GO_TO_URL__URL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGO_TO_URLAccess().getUrlSTRINGTerminalRuleCall_1_0(), semanticObject.getUrl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Verifiable returns IMAGE
	 *     Clickable returns IMAGE
	 *     IMAGE returns IMAGE
	 *
	 * Constraint:
	 *     (name=STRING params+=PARAMS*)
	 */
	protected void sequence_IMAGE(ISerializationContext context, IMAGE semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns INSERT_ON
	 *     INSERT_ON returns INSERT_ON
	 *
	 * Constraint:
	 *     (element=Insertable (data=STRING | data=ID))
	 */
	protected void sequence_INSERT_ON(ISerializationContext context, INSERT_ON semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Readable returns LINK
	 *     Verifiable returns LINK
	 *     Clickable returns LINK
	 *     LINK returns LINK
	 *
	 * Constraint:
	 *     url=STRING
	 */
	protected void sequence_LINK(ISerializationContext context, LINK semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BrowserAutomationPackage.Literals.LINK__URL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BrowserAutomationPackage.Literals.LINK__URL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLINKAccess().getUrlSTRINGTerminalRuleCall_1_0(), semanticObject.getUrl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns OPEN_BROWSER
	 *     OPEN_BROWSER returns OPEN_BROWSER
	 *
	 * Constraint:
	 *     {OPEN_BROWSER}
	 */
	protected void sequence_OPEN_BROWSER(ISerializationContext context, OPEN_BROWSER semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PARAMS returns PARAMS
	 *
	 * Constraint:
	 *     (key=STRING value=STRING)
	 */
	protected void sequence_PARAMS(ISerializationContext context, PARAMS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BrowserAutomationPackage.Literals.PARAMS__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BrowserAutomationPackage.Literals.PARAMS__KEY));
			if (transientValues.isValueTransient(semanticObject, BrowserAutomationPackage.Literals.PARAMS__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BrowserAutomationPackage.Literals.PARAMS__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPARAMSAccess().getKeySTRINGTerminalRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getPARAMSAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns READ_ON
	 *     READ_ON returns READ_ON
	 *
	 * Constraint:
	 *     element=Readable
	 */
	protected void sequence_READ_ON(ISerializationContext context, READ_ON semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BrowserAutomationPackage.Literals.READ_ON__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BrowserAutomationPackage.Literals.READ_ON__ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getREAD_ONAccess().getElementReadableParserRuleCall_1_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RefElement returns RefElement
	 *     Verifiable returns RefElement
	 *     Clickable returns RefElement
	 *
	 * Constraint:
	 *     ref=[AFFECTATION|ID]
	 */
	protected void sequence_RefElement(ISerializationContext context, RefElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BrowserAutomationPackage.Literals.REF_ELEMENT__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BrowserAutomationPackage.Literals.REF_ELEMENT__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRefElementAccess().getRefAFFECTATIONIDTerminalRuleCall_0_1(), semanticObject.eGet(BrowserAutomationPackage.Literals.REF_ELEMENT__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Insertable returns SEARCH_FIELD
	 *     Clickable returns SEARCH_FIELD
	 *     SEARCH_FIELD returns SEARCH_FIELD
	 *
	 * Constraint:
	 *     name=STRING
	 */
	protected void sequence_SEARCH_FIELD(ISerializationContext context, SEARCH_FIELD semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BrowserAutomationPackage.Literals.SEARCH_FIELD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BrowserAutomationPackage.Literals.SEARCH_FIELD__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSEARCH_FIELDAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SELECTOR returns SELECTOR
	 *
	 * Constraint:
	 *     (readable=Readable params+=PARAMS number=INT)
	 */
	protected void sequence_SELECTOR(ISerializationContext context, SELECTOR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Readable returns TEXT
	 *     Verifiable returns TEXT
	 *     TEXT returns TEXT
	 *
	 * Constraint:
	 *     name=STRING
	 */
	protected void sequence_TEXT(ISerializationContext context, TEXT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BrowserAutomationPackage.Literals.TEXT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BrowserAutomationPackage.Literals.TEXT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTEXTAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Test returns Test
	 *
	 * Constraint:
	 *     (name=STRING instructions+=Instruction*)
	 */
	protected void sequence_Test(ISerializationContext context, Test semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns VERIFY_THAT
	 *     VERIFY_THAT returns VERIFY_THAT
	 *
	 * Constraint:
	 *     element=Verifiable
	 */
	protected void sequence_VERIFY_THAT(ISerializationContext context, VERIFY_THAT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BrowserAutomationPackage.Literals.VERIFY_THAT__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BrowserAutomationPackage.Literals.VERIFY_THAT__ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVERIFY_THATAccess().getElementVerifiableParserRuleCall_1_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
}
